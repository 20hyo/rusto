use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;
use uuid::Uuid;

/// Side of a trade or order
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Side {
    Buy,
    Sell,
}

impl Side {
    pub fn opposite(self) -> Self {
        match self {
            Side::Buy => Side::Sell,
            Side::Sell => Side::Buy,
        }
    }
}

/// Normalized trade from exchange
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NormalizedTrade {
    pub symbol: String,
    pub price: Decimal,
    pub quantity: Decimal,
    pub side: Side,
    pub timestamp: DateTime<Utc>,
    pub trade_id: u64,
}

/// Depth update (bid/ask level)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DepthLevel {
    pub price: Decimal,
    pub quantity: Decimal,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DepthUpdate {
    pub symbol: String,
    pub bids: Vec<DepthLevel>,
    pub asks: Vec<DepthLevel>,
    pub timestamp: DateTime<Utc>,
}

/// Market data event (union of trade and depth)
#[derive(Debug, Clone)]
pub enum MarketEvent {
    Trade(NormalizedTrade),
    Depth(DepthUpdate),
}

/// Footprint: volume at each price level within a bar
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct FootprintLevel {
    pub bid_volume: Decimal,
    pub ask_volume: Decimal,
}

/// Range bar with embedded footprint data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RangeBar {
    pub symbol: String,
    pub open: Decimal,
    pub high: Decimal,
    pub low: Decimal,
    pub close: Decimal,
    pub volume: Decimal,
    pub buy_volume: Decimal,
    pub sell_volume: Decimal,
    pub open_time: DateTime<Utc>,
    pub close_time: DateTime<Utc>,
    pub footprint: BTreeMap<String, FootprintLevel>, // price_key -> volumes
    pub bar_index: u64,
}

impl RangeBar {
    pub fn delta(&self) -> Decimal {
        self.buy_volume - self.sell_volume
    }
}

/// Volume profile for a session
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VolumeProfileSnapshot {
    pub symbol: String,
    pub poc: Decimal,  // Point of Control - highest volume price
    pub vah: Decimal,  // Value Area High
    pub val: Decimal,  // Value Area Low
    pub total_volume: Decimal,
    pub session_high: Decimal,
    pub session_low: Decimal,
    pub timestamp: DateTime<Utc>,
}

/// Order flow metrics for a bar
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderFlowMetrics {
    pub symbol: String,
    pub cvd: Decimal,               // Cumulative Volume Delta
    pub bar_delta: Decimal,          // Delta for current bar
    pub absorption_detected: bool,
    pub absorption_side: Option<Side>, // Side being absorbed
    pub imbalance_ratio: Decimal,
    pub timestamp: DateTime<Utc>,
}

/// Setup type for trading signals
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum SetupType {
    AAA,                  // Absorption At Area
    MomentumSqueeze,      // Breakout with delta confirmation
    AbsorptionReversal,   // Pure absorption reversal
}

impl std::fmt::Display for SetupType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SetupType::AAA => write!(f, "AAA"),
            SetupType::MomentumSqueeze => write!(f, "MomentumSqueeze"),
            SetupType::AbsorptionReversal => write!(f, "AbsorptionReversal"),
        }
    }
}

/// Trading signal generated by strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradeSignal {
    pub id: String,
    pub symbol: String,
    pub side: Side,
    pub setup: SetupType,
    pub entry_price: Decimal,
    pub stop_loss: Decimal,
    pub take_profit: Decimal,
    pub confidence: Decimal,
    pub timestamp: DateTime<Utc>,
}

impl TradeSignal {
    pub fn new(
        symbol: String,
        side: Side,
        setup: SetupType,
        entry_price: Decimal,
        stop_loss: Decimal,
        take_profit: Decimal,
        confidence: Decimal,
    ) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            symbol,
            side,
            setup,
            entry_price,
            stop_loss,
            take_profit,
            confidence,
            timestamp: Utc::now(),
        }
    }
}

/// Position status
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum PositionStatus {
    Open,
    Closed,
}

/// Simulated position
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Position {
    pub id: String,
    pub symbol: String,
    pub side: Side,
    pub entry_price: Decimal,
    pub quantity: Decimal,
    pub stop_loss: Decimal,
    pub take_profit: Decimal,
    pub setup: SetupType,
    pub status: PositionStatus,
    pub pnl: Decimal,
    pub entry_time: DateTime<Utc>,
    pub exit_time: Option<DateTime<Utc>>,
    pub exit_price: Option<Decimal>,
    pub break_even_moved: bool,
}

/// Events flowing through the processing pipeline
#[derive(Debug, Clone)]
pub enum ProcessingEvent {
    NewBar(RangeBar),
    VolumeProfile(VolumeProfileSnapshot),
    OrderFlow(OrderFlowMetrics),
    Signal(TradeSignal),
}

/// Events from the execution engine
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExecutionEvent {
    PositionOpened(Position),
    PositionClosed(Position),
    StopMoved { position_id: String, new_stop: Decimal },
    DailyLimitReached { pnl: Decimal },
}
